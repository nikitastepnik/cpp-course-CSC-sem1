= Семинар №1. Организация разработки программ на С++
:icons: font
:table-caption!:
:cls01ple-caption!:
:source-highlighter: highlightjs
:revealjs_hash: true
:customcss: https://gistcdn.githack.com/fedochet/4ee0f4a2224ecd29a961082a0c63c020/raw/18c107982aba90bb94194c0ac3a8a5ca9bad6782/asciidoc_revealjs_custom_style.css
:revealjs_theme: blood
:stylesheet: main.css
:toc:
:toclevels: 4

== Информация о семинарах

- Филипп Грабовой, гитхаб: https://github.com/Sviftel[@Sviftel]
- Андрей Серебро, гитхаб: https://github.com/Aspirisha[@Aspirisha]
- Николай Меркин, гитхаб: https://github.com/Nickolaym[@Nickolaym]

ifdef::backend-revealjs[=== !]

* занятие раз в неделю
* вопросы по прошлым работам + разбор тонких моментов
* новый материал + задачи
** решения оцениваются по тестам и ревьювятся (не целиком)
* время: если не успеваем до 21:30 — может быть добавлено +45минут
** выносится необязательная часть, advanced-материал
* общение в дискорде (*) курса

=== дорешки
* 1 неделя на выполнение и сдачу
* в дорешке несколько пунктов — приемка _позадачная_
** можно решить не все и получить баллы
* есть тесты — необходимо пройти их для сдачи задачи
* будет выборочное ревью решений (по возможностям преподавателей)

=== контрольные
* каждый 4-ый семинар — контрольная  (3 шт)
* обычно это Задача с частями на 3, 4, 5 баллов
* решается за 2 занятия (пары лекции + семинара) — 3 часа
* для сдачи надо пройти тесты + ревью решения

=== заметки
* https://github.com/cpp-practice/cpp-public-2223[cpp-practice/cpp-public-2223]
** _для этого года тоже появится позже (или общая версия)_
** есть про оценивание
** есть ссылка на общую ведомость

== Семинары: самостоятельная работа
* github+git: получить презентацию и код
* IDE: написать решение
* компилятор+CMake: отладить решение
* git: отправить на проверку

=== Что нужно установить+знать
- Набор инструментов для компиляции `C++`
* Компилятор
* Сборщики `Make` и `CMake`
- Установленный git и аккаунт на https://www.github.com
- Редактор для кода/IDE

=== git
* годный инструмент вне курса
* скорее всего не все будет работать по кнопке
* хорошее руководство (en/ru): https://git-scm.com/book/en/v2[git book]
* хороший курс: https://learngitbranching.js.org/[learngitbranching]

=== Сборка
* Компиляция — важно понимать, вникать в ошибки, исправлять их
* Первое время лучше напрямую компилировать из командой строки

* При постоянной работе с `C++` удобны системы сборки. На нашем курсе — `Makefile` (немного), `CMake`

=== Чем собирать
* Unix-like ОС, установленный компилятор
** Это предпочтительная конфигурация для прохождения курса
** Компилятор `g\++` или `clang++`, `CMake` и т.д. устанавливаются пакетными менеджерами
** Гуглить `install <tool> on <OS>`, например `install g++ on ubuntu 20.04`

ifdef::backend-revealjs[=== !]

* Windows ОС, установленная Visual Studio + её компилятор (или аналоги)
** Самый простой путь -- установить Visual Studio и пользоваться ей. Она содержит компилятор и CMake
** Путь сложнее -- виртуалка с unix, WSL
** Путь еще сложнее -- mingw или cygwin. Погуглите, как это установить

=== Про classroom
* https://gist.github.com/Sviftel/9cbd6cf6e2e3b4e898a11df742d274e7[gist с описанием]
* + в public-репозитории есть правила сдачи дорешки

== Цели занятия
- Научиться компилировать простые программы на `C++`
- Научиться определять и объявлять переменные встроенных типов
- Поработать с функциями, циклами и условиями
- Освоить ввод/вывод в консоль и в файл стандартными средствами `C++`
- Посмотреть, с чем работает проверяющая система

== Компиляция программ на C++ (для Unix)

Создать исполняемый файл из файла с исходным кодом в `main.cpp`.
Результат: исполняемый файл `a.out`

[code]
----
$ g++ main.cpp
----

Запустить исполняемый файл

[code]
----
$ ./a.out
----

ifdef::backend-revealjs[=== !]

Мы будем всегда указывать флаги о дополнительных предупреждениях от компилятора

[code]
----
$ g++ main.cpp -Wall -Werror
----

=== пособираем программу в live-режиме

* `std::cout`, `std::cin`
* `assert`
* сделаем программу многофайловой

=== что нужно для сдачи дорешки #1
* решения в `src/task_N`
* `Makefile`-инструкции по сборке для `g++` (!)
** habr: https://habr.com/ru/post/155201/[Makefile для самых маленьких]
** требуемые команды указаны в заготовке + указаны в `.github/classroom/autograding.json`

== Плюсы для cls01

=== Примеры управляющих конструкций

Тернарный оператор
[source,cpp]
----
if (<condition>) {
    // ...
} else { /* ... */ }
----

* `<condition>` — выражение типа bool или _приводимое к нему_
* else-часть опциональна

ifdef::backend-revealjs[=== !]

Цикл for
[source,cpp]
----
for (<init>; <condition>; <step>) {
    // ...
}
----

* `init` — может быть определением (`int i = 0`) или выражением
* `<condition>` — выражение типа bool или _приводимое к нему_, проверяется перед каждой итерацией
* `<step>` — выражение, выполняемое в конце каждой итерации (`++i`)


== Разрядность и арифметика

* `sizeof` — встроенный оператор, возвращающий размер типа
* по стандарту: `sizeof(int) >= 2` (на наиболее частых платформах — `4`)
* есть типы с фиксированным размером, например `[u]int32_t`
* => на арифметических операциях возможно переполнение 

ifdef::backend-revealjs[=== !]

* переполнение на знаковых типах — это UB [*]
* переполнение на беззнаковых типах — это корректное вычисление в соотв. кольце вычетов по модулю 2^N

* [*]: https://en.cppreference.com/w/cpp/language/ub[Undefined Behaviour] — непредсказуемое [с т.з. стандарта] состояние программы
** попасть в него можно из-за неаккуратного кода/отсутствия проверок (выполнения инстукций, которые приводят к UB)
** от компиляторов не требуется поддерживать корретную работу программы в таком сценарии

== Зачем нужны заголовочные файлы?

Одна из основных целей хедеров -- делить объявления функций между различными единицами компиляции: реализация отдельно от использования

=== про компиляцию

Особенность компиляторов `C` и `C++`:

* каждый `.c/.cpp` файл компилируется *изолированно друг от друга* -> объектные файлы
* они объединяются (линкуются) в итоговый исполняемый файл

ifdef::backend-revealjs[=== !]

Рассмотрим файлы `main.cpp` и `file.cpp`. В `file.cpp` реализованы функции для работы с файлами

.file.cpp
[source,cpp]
----
...

string read(string const& file_name, uint64_t offset) { ... }

...
----

.main.cpp
[source,cpp]
----
int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----


ifdef::backend-revealjs[=== !]

* `main.cpp` использует `read`
* компиляция `main.cpp` *отдельно*
* => не проверить, что в `file.cpp` есть такая функция там есть
** и что у неё подходящая сигнатура

ifdef::backend-revealjs[=== !]

* Выход: используем заголовочный файл и директивы препроцессора `#include`
* Создадим заголовочный файл `file.hpp` с таким декларированием:

.file.hpp
[source,cpp]
----
#pragma once

string read(string const& file_name, uint64_t offset);
----

ifdef::backend-revealjs[=== !]

Модифицируем файлы `main.cpp` и `file.cpp`, чтобы они оба включали заголовочный файл в себя:

.file.cpp
[source,cpp]
----
#include "file.hpp"

string read(string const& file_name, uint64_t offset) { ... }

...
----

.main.cpp
[source,cpp]
----
#include "file.hpp"

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

ifdef::backend-revealjs[=== !]

Когда компилятор будет обрабатывать эти файлы, он заменит `#include`-ы на содержимое
файлов, на которые они указывают. Например, `main.cpp` будут выглядеть так:

.main.cpp с вставкой
[source,cpp]
----
#pragma once  // на самом деле эта конструкция опустится

string read(string const& file, uint64_t offset);

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

ifdef::backend-revealjs[=== !]

Теперь везде есть объявления функции `read`, где включен заголовочник.
Объявления достаточно, чтобы компилятор смог создать объектный файл

При линковке: если определение функции так и не будет найдено, то компилятор (линковщик)
выдаст ошибку линковки вида `undefined reference to read(string const&, uint64_t) in main.cpp`

=== Про декларацию функций[*]

.main.cpp с вставкой
[source,cpp]
----
...
// рассмотрим варианты:
string read(string const& file, uint64_t offset);
// ИЛИ
string read(string const& file, uint32_t offset);

int main() {
    cout << read("input.txt", 0) << endl;
    return 0;
}
----

ifdef::backend-revealjs[=== !]

* важно представление литерала `0` в данных
** какой параметр (какого размера, какой битности) им инициализируется
* https://godbolt.org/z/83dfeaa39[godbolt] — попробовать `Ou`, `0ul`

ifdef::backend-revealjs[=== !]

****
У компилятора `g++` есть опция `-E`, позволяющая посмотреть, как будут выглядеть единицы компиляции
после препроцессинга
****

== Задачи

[NOTE]
====
Если вы видите несоответствие между заданием здесь и в коде (в тестах):

1. Сообщите об этом преподавателю
2. Ориентируйтесь на код, если нет жестких противоречий
====

ifdef::backend-revealjs[=== !]

Требования к задачам: 

- Используйте `cin` и `cout` для вывода при выполнении задач, это необходимо для тестов; не используйте другие способы вывода (в том числе `printf` и прочее), если этого не сказано явно

=== Задача №1. Hello World

Напишите и скомпилируйте программу с функцией `say_hello`, выводящей `Hello, world!` в стандартный вывод

Сигнатура функции:

[source,cpp]
----
void say_hello();
----

Объявите функцию в заголовочном файле `hello.hpp`, а её тело реализуйте в файле `hello.cpp`

=== Задача №2. Fizz Buzz

Напишите функцию, которая выводит на экран числа от `1` до `n`. Вместо чисел, кратных трем, программа должна выводить слово `Fizz`, а вместо чисел, кратных пяти — слово `Buzz`. Если число кратно пятнадцати, то программа должна выводить слово `FizzBuzz`

Сигнатура функции: 

[source,cpp]
----
void fizzbuzz(uint8_t n);
----

ifdef::backend-revealjs[=== !]

Объявите функцию в заголовочном файле `fizzbuzz.hpp`, а её тело реализуйте в файле `fizzbuzz.cpp`

ifdef::backend-revealjs[=== !]

Результат вызова `fizzbuzz(15)`: 
====

[source,cpp]
----
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
----
====

=== Задача №3

Напишите функцию `compute_fib`, считывающую из `input.txt` целое `N` и возвращающую `N`-ное число Фибоначчи

Число фибоначчи рекомендуется считать нерекурсивно

Сигнатура функции: 

[source,cpp]
----
int64_t compute_fib();
----

ifdef::backend-revealjs[=== !]

Объявите функцию в заголовочном файле `compute_fib.hpp`, а её тело реализуйте в файле `compute_fib.cpp`

